# RocketMQ 基本概念 [返回](/ "首页")

## 生产者

生产者发送业务系统产生的消息给broker。RocketMQ提供了多种发送方式：同步的、异步的、单向的。

### 生产者组

具有相同角色的生产者被分到一组。假如原始的生产者在事务后崩溃，broker会联系
同一生产者组中的不同生产者实例，继续提交或回滚事务。

## 消费者

一个消费者从broker拉取信息，并将信息返还给应用。为了我们应用的正确性，提供了两种消费者类型：

### 拉式消费者

拉式消费者从broker拉取消息，一旦一批消息被拉取，用户应用系统将发起消费过程。

### 推式消费者

推式消费者，从另一方面讲，囊括了消息的拉取、消费过程，并保持了内部的其他工作，留下了一个回调
接口给终端用户去实现，实现在消息到达时要执行的内容。

### 消费者组

具有相同角色的消费者被组在一起，称为消费者组。它是一个伟大的概念，它完成了负载均衡和容错的目标。
就消费消息而言，它是非常容易的。

一个消费组中的消费者实例必须有确定的相同的订阅topic。

## Topic

Topic是一个消息的目录，在这个目录中，生产者传送消息，消费者拉取消息。Topic与生产者和消费者之间的关系非常的宽松。
明确的，一个Topic可以有0个，1个或多个生产者向它发送消息。相反的，一个生产者可以发送不同Topic的消息。
在消费者方面，一个Topic可以被0个，1个或多个消费者组订阅。相似的，一个消费者组可以订阅1个或多个Topic，只要组内的消费者实例
保持订阅的一致性。

## Message（消息）

消息是被传递的信息。一个消息必须有一个Topic，它可以理解为信件上的地址。一个消息也可以有一个可选的tag，和额外的key-value对。
例如：你可以设置业务中的键到你的消息中，在broker服务中查找消息，以便在开发期间诊断问题。

## 消息队列

Topic被分割成一个或多个消息队列。队列分为3中角色：异步主、同步主、从。如果你不能容忍消息丢失，我们建议你部署同步主，并加一个从队列。
如果你容忍丢失，但你希望队列总是可用，你可以部署异步主和从队列。如果你想最简单，你只需要一个异步主，不需要从队列。
消息保存磁盘的方式也有两种，推荐使用的是异步保存，同步保存是昂贵的并会导致性能损失，如果你想要可靠性，我们推荐你使用同步主+从的方式。

## Tag（标签）

标签，用另外一个词来说，就是子主题，为用户提供额外的灵活性。具有相同Topic的消息可以有不同的tag。

## Broker（队列）

Broker是RocketMQ的一个主要组件，它接收生产者发送的消息，存储它们并准备处理消费者的拉取请求。它也存储消息相关的元数据，
包括消费组，消费成功的偏移量，主题、队列的信息。

## 名称服务

名称服务主要提供路由信息。生产者/消费者客户端寻找topic，并找到通信的队列列表。

## 消息顺序

当`DefaultMQPushConsumer `被使用，你就要决定消费消息时，是顺序消费还是同时消费。

* 顺序消费

顺序消费消息的意思是 消息将按照生产者发送到队列时的顺序被消费掉。如果你被强制要求使用全局的顺序，你要确保你的topic只有一个消息队列。

如果指定顺序消费，消息被同时消费的数量就是订阅这个topic的消费组的数量。

* 同时消费

当同时消费消息时，消息同时消费的最大数量取决于消费客户端指定的线程池的大小。


